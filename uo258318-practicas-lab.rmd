---
title: "Prácticas de laboratorio de Administración de Sistemas y Redes - UO258318"
author: Hugo Fonseca Díaz (UO258318)
output: pdf_document
---

# Práctica 1

## Primera parte: Instalación Linux

Creamos un máquina virtual de tipo "Red Hat (64 bits)", en nuestro caso la hemos llamado *CentOS-UO258318*.
Seguimos las instrucciones del guión de la práctica, haciendo una instalación mínima, asignándole la contraseña EIIASR2018$ a root y por último creando un usuario *uo258318* con una contraseña a nuestra elección.

Entramos en la máquina como root.

![CentOS iniciado con sesión de root después de la instalación.](screenshots/screenshot-01-centOS_after_install.png)

Realizamos una actualización con el comando *yum update*.

![Comando yum update finalizado](screenshots/screenshot-02-yum_update.png)


## Segunda parte: Instalación Windows 2008 R2

Creamos una nueva máquina virtual con una instalación nueva de "Windows 2008 64 bits". Le asignamos al administrador la misma contraseña que tiene root en nuestra máquina CentOS, EIIASR2018$. Por último, le cambiamos el nombre al equipo por el de W2008R2 y le asignamos al grupo de trabajo AS.

![Windows 2008 R2 instalado y configurado](screenshots/screenshot-12-winstall.png)


## Tercera parte: Iniciar sesión Linux

### Tarea 1 - Kernel

Debemos cambiar la configuración del gestor de arranque GRUB para que se siga usando la versión antigua del Kernel.
Ejecutamos el comando *grep menuentry /boot/grub2/grub.cfg* para ver las opciones de menú disponibles al botar la máquina.

Una vez hecho esto, editamos (en nuestro caso con el editor *vim*) el fichero */etc/default/grub* y cambiamos la línea *GRUB_DEFAULT=saved* por *GRUB_DEFAULT=1*.

![Editando */etc/default/grub* con *Vim*](screenshots/screenshot-03-vim_grub.png)

Actualizamos el grub con el comando *grub2-mkconfig -o /boot/grub2/grub.cfg* y reiniciamos la máquina para comprobar que la instalación es correcta.

Una vez hecho esto volvemos a dejar la máquina con el kernel más actualizado.

El archivo donde se encuentra el kernel es */boot/vmlinuz-3.10.0-957.21.2.e17.x86_64*

### Tarea 2 - Systemd

Ejecutamos el comando *ps ax* para ver la lissta de procesos. Vemos que el primero es systemd.
Con la orden *systemctl get-default* se nos muestra el target, que vemos que es *multi-user.target*
Para cambiar de modo utilizaremos la orden *systemctl isolate*.
Al hacer *systemctl isolate runlevel6.target* el equipo se reinicia, ya que el runlevel número seis es el nivel de reinicio de la máquina.
Si queremos que el sistema se inicie en un target diferente utilizaremos el comando *systemctl set-default*.

El PID (Process Identifier) del proceso systemd es el PID 1.

![Comando *ps ax | less*](screenshots/screenshot-04-ps_ax.png)

El runlevel del sistema por defecto es el multi-user, representado por el runlevel 3. Al ejecutar el comando *systemctl isolate rescue.target* el runlevel pasa a ser el 1.

Cuando el runlevel por defecto es el uno, al iniciarse el sistema se ejecuta el modo de emergencia, por lo que solo puedes loggearte como root.

Al correr el comando *systemctl isolate runlevel6.target* la máquina se reinicia.

### Tarea 3 - Login desde terminales

Con las teclas *ALT + FUNCION* podemos cambiar a una consola diferente. Iniciando sesión de nuevo como root en esta consola, podremos ejecutar el comando *ps ax | less* para buscar el PID del antiguo proceso del bash, y matarlo con el comando *kill -9 3438*.

![Comando *kill -9 3438*](screenshots/screenshot-05-kill_9.png)

Al volver a la primera consola vemos que se ha lanzado un proceso *agetty* que nos vuelve a pedir nuestro usuario y contraseña.

### Tarea 4 - Syslog

Ejecutamos el comando last para ver que usuarios han hecho login recientemente y los motivos de las últimas caídas del equipo.

![Comando *last* (Antes de simular caída de tensión)](screenshots/screenshot-06-last.png)

Apagamos de forma anómala la máquina virtual desde virtualbox. Ejecutamos el comando *last* de nuevo.

![Comando *last* (Después de simular caída de tensión)](screenshots/screenshot-07-crash.png)

Como vemos en la tercera entrada, según el output de la orden *last*, el ordenador se ha apagado debido a un crasheo.

### Tarea 5 - Ejecución periódica de comandos

El script encargado de borrar los ficheros con los logs más antiguos y de rotar cada día los ficheros de log se llama *logrotate*, y se encuentra en la carpeta */etc/cron.daily/*.

![Script *logrotate*](screenshots/screenshot-08-logrotate.png)

### Tarea 6 - Login desde Red

Nos conectamos mediante *ssh* a nuestro equipo por medio de *localhost*.
Una vez hecho eso, abrimos una nueva terminal con *ALT + F2* y ejecutamos el comando *ps ax | less*. Después, nos conectamos desde esta segunda terminal mediante *ssh* a *localhost*, y corremos de nuevo el comando *ps ax | less*.

![Comando *ps ax | less* desde la conexión *ssh*](screenshots/screenshot-09-ssh_madness.png)

Como podemos observar, los dos procesos *ssh* tienen PID 3476 para la terminal *tty1* y PID 3522 para la terminal *tty2*. 

El segundo proceso *sshd* de PID 3523 figura en la terminal *tty2*.

### Tarea 7 - Sistemas de ficheros en red

Nos descargamos *Samba* con la orden *yum install samba*, y comprobamos su manual con *man samba*.

![Página de manual de *Samba*](screenshots/screenshot-10-man_samba.png)

### Tarea 8 - Correo electrónico

En esta tarea, con el agente de correo *mail*, debemos enviar un email a root.
Para leerlo, deberemos ejecutar la orden *mail*, que nos muestra una lista de los mensajes, y tecleando el número del mensaje podremos leerlo.

Por último, miraremos la ayuda de *mail* para encontrar el comando que nos permita salir del programa, que en este caso puede ser *quit*.

![Saliendo de *mail*](screenshots/screenshot-11-mail.png)

### Tarea 9 - Servicios de impresión.

El *Common Unix Printing System* es un estándar de impresión para sistemas tipo UNIX. Suele ser muy utilizado en entornos GNU/Linux y similares.



# Práctica 2

## A. Recuperación básica de errores durante el inicio

### 1.

Editamos el fichero */boot/grub2/grub.cfg* y buscamos la primera aparición de la palabra *linux16*. Después, cambiaremos el nombre al archivo *vmlinuz* y lo sustituiremos por *vmlinux*. Al rebotar la máquina observaremos cómo el sistema nos muestra un error advirtiéndonos de que el archivo con el nuevo nombre no existe.

### 2.

Introducimos el disco de instalación y botamos en modo de rescate. Corremos la orden *chroot /mnt/sysimage* y corregimos el fichero *grub.cfg*.

![Modo de rescate](screenshots/screenshot-13-rescue.png)

Apagamos el equipo y extraemos el disco de instalación. Al arrancarlo la primera vez el sistema no llegó a botar correctamente y se nos devuelve al menú de GRUB, pero en esta seguna ocasión la máquina inicia sin problemas y se nos pide el usuario y contraseña como es habitual.

### 3.

Volvemos a editar *grub.cfg* y realizamos el cambio de nombre *vmlinuz* por *vmlinux*. Rebotamos, y en esta ocasión editamos el nombre del kernel desde el propio GRUB.
Observamos que la máquina bota sin problemas.

### 4.

Al editar de nuevo *grub.cfg*, vemos que el nombre del kernel sigue siendo erróneo, esto se debe a que lo que hemos cambiado previamente ha sido lo que GRUB tenía cargado en memoria, no el propio archivo de configuración.

![Editando *grub.cfg*](screenshots/screenshot-14-grub_not_changed.png)


## B. Instalación de Linux con particionamiento estático

### Particionamiento manual

En esta tarea deberemos crear una nueva máquina virtual con las especificaciones vistas en la práctica 1. Esta nueva máquina tendrá dos discos, cuyas particiones quedarán de la forma que observamo en la siguiente captura.

![Particionamiento](screenshots/screenshot-15-part_manual.png)

Una vez instalado, ejecutaremos los comandos *df -Th* y *lsblk*, cuyo output se muestra en la siguiente imagen.

![Output de los comandos *df -Th* y *lsblk*](screenshots/screenshot-16-partitions.png)

### Adición de un tercer disco a un sistema ya instalado

Ahora debemos crear un tercer disco desde virtualbox con el sistema apagado.

El nombre del fichero de dispositivo del nuevo disco será *sdc*.

#### Uso de fdisk

Al correr la orden *fdisk /dev/sdc* se nos muestra un mensaje de error advirtiéndonos de que el dispositivo no cuenta con una tabla de particiones.

Después de crear las particiones correspondientes, el output de *fdisk* con el parámetro *p* se visualiza en la siguiente imagen.

![Output de *fdisk* con el parámetro *p*](screenshots/screenshot-17-fdisk_p.png)

#### Creación del filesystem: mkfs

Ejecutaremos el comando *mkfs /dev/sdc1* para crear un sistema de archivos de tipo *ext2* en la partición de 512 MB del disco.

Una vez hecho esto, crearemos una etiqueta para esta partición usando la orden *e2label /dev/sdc1 primpart*, siendo *primpart la etiqueta que le hemos asignado.

Por último, con la orden *tune2fs -j /dev/sdc1* creamos el archivo de journal y hacemos que el filesystem sea dde tipo *ext3*.

Repetimos ahora el proceso para las otras particiones.

A la hora de ejecutar el comando *mkfs /dev/stc2* el sistema nos muestra un error debido a que esta partición es de tipo extendida, y es la que contiene las últimas dos particiones.

Para estas últimas dos particiones, los comandos que he utilizado son los siguientes.

Para *sd5*, *mkfs /dev/sdc5*, *e2label /dev/sdc5 part1logical* y *tune2fs -j /dev/sdc5*.

Para *sd6*, *mkfs /dev/sdc6*, *e2label /dev/sdc6 part2logical* y *tune2fs -j /dev/sdc6*.

#### Montaje del filesystem: mount, /etc/fstab

Después de montar los filesystems, el output de la orden *mount* es el que podemos observar en la siguiente captura.

![Output del comando *mount*](screenshots/screenshot-18-mount_output.png)

El sistema de archivos de */dev/sdc1* es de tipo *ext3* y el de */dev/sda1* es de tipo *xfs*.

Para terminar, se nos manda cambiar el tipo de partición de Linux a FAT32 en las dos unidades lógicas, y crear filesystems de tipo *msdos* y *vfat* en ambas.

La secuencia de pasos es la siguiente:

- Orden *fdisk /dev/sdc*
- Parámetro *p* para listar las particiones
- Parámetro *t* para cambiar el tipo de partición
- Elegimos el número de la partición que deseamos modificar, ya sea la número 5 o la 6
- Parámetro *b*, que identifica a FAT32
- Parámetro *w* para escribir los cambios en disco
- Instalamos el paquete *dosfstools* con la orden *yum install dosfstools*
- Orden *umount /mnt/asuka*
- Orden *umount /mnt/kanbaru*
- Orden *mkfs /dev/sdc5 -t msdos*
- Orden *mkfs /dev/sdc6 -t vfat*


## C. Instalación de Linux con particionamiento dinámico

### Part 1

Reinstalamos un linux sobre LVM en la máquina usada previamente en esta práctica. El resultado del particionamiento lo podremos visualizar en la siguiente captura.

![Particionamiento de la nueva instalación](screenshots/screenshot-19-lvm_installation.png)

Una vez instalado, se nos manda ejecutar la orden *df* y mostrar el resultado, que se puede observar en esta imagen.

![Output del comando *df*](screenshots/screenshot-20-df_output.png)

### Part 2

En esta parte, tendremos que asignarle el espacio del tercer disco duro al volumen lógico que está montado en */home*.

Debemos hacer los siguientes pasos:

- Orden *fdisk /dev/sdc*
- Parámetro *d* y el número de la partición a eliminar. Hacemos esto con todas las particiones
- Parámetro *n* y todas las opciones por defecto para crear una nueva partición que ocupe todo el disco
- Parámetro *t* con código *8e* para darle a la partición el tipo *Linux LVM*
- Orden *pvcreate /dev/sdc1*
- Orden *vgscan*
- Orden *vgextend centos /dev/sdc1*
- Demontamos */home* con la orden *umount /home*
- Orden *lvextend -L +512M /dev/centos/home*
- Montamos */home* de nuevo con la orden *mount /dev/centos/home /home*
- Orden *xfs_growfs -d /home*

El output de los comandos *pvscan*, *lvscan*, *df /home* es el siguiente.

![Output de los comandos *pvscan*, *lvscan*, *df /home*](screenshots/screenshot-21-part2_orders.png)


## D. Instalación de Linux con RAID y recuperación ante fallos

Reinstalamos un Linux sobre RAID en la máquina que se ha estado utilizando.
Su particionamiento lo podremos contemplar en la siguiente imagen.

![Particionamiento de la nueva instalación](screenshots/screenshot-22-raid_part.png)

El output de los comandos *df*, *mdadm --detail /dev/md126* y *mdadm --detail /dev/md127* es el siguiente.

![Output del comando *df*](screenshots/screenshot-23-df_output.png)

![Output del comando *mdadm --detail /dev/md126*](screenshots/screenshot-24-mdadm_md126.png)

![Output del comando *mdadm --detail /dev/md127*](screenshots/screenshot-25-mdadm_md127.png)

En nuestro caso el RAID montado */boot* se llama */dev/md127* y el montado en */* se llama */dev/md126*.

Indicamos que ha habido un fallo en la partición del disco *sdc* usada en el RAID1 con la orden *mdadm --manage /dev/md127 --fail /dev/sdc2*.
Ejecutamos el comando *mdadm --detail /dev/md127*, que nos devuelve el siguiente resultado.

![Output del comando *mdadm --detail /dev/md127* después del fallo del disco *sdc*](screenshots/screenshot-26-after_disc_failure.png)

Eliminamos el disco fallido con la orden *mdadm --manage /dev/md127 --remove /dev/sdc2*.
Ejecutamos la orden *mdadm --detail /dev/md127*, que nos muestra lo siguiente.

![Output del comando *mdadm --detail /dev/md127* después de eliminar el disco *sdc*](screenshots/screenshot-27-after_disc_removal.png)

A continuación redimensionamos el RAID a tamaño 2 con la orden *mdadm --grow /dev/md127 --raid-devices=2*.
Al correr el comando *mdadm --detail /dev/md127* obtendremos el siguiente resultado.

![Output del comando *mdadm --detail /dev/md127* después de redimensionar el RAID](screenshots/screenshot-28-after_raid_redimensioning.png)

Añadimos la partición del disco *sdc* como *hotspare*, utilizando la orden *mdadm -a /dev/md127 /dev/sdc2*.
El output de la orden *mdadm --detail /dev/md127* muestra lo siguiente.

![Output del comando *mdadm --detail /dev/md127* después de añadir la partición como *hotspare*](screenshots/screenshot-29-hotspare.png)

En esta ocasión simularemos un fallo en el RAID 5.
Para ello, le indicaremos a la máquina que ha habido un fallo en la partición del disco *sdc*, usando el comando *mdadm --manage /dev/md126 --fail /dev/sdc3*.
Al ejecutar la orden *mdadm --detail /dev/md126* obtendremos la siguiente información.

![Output del comando *mdadm --detail /dev/md126* después del fallo en el disco *sdc*](screenshots/screenshot-30-md126_after_sdc_fail.png)

Ahora, simularemos que el disco que ha fallado se reemplaza por un disco nuevo, inicializando la partición con *mkfs*.

Lo primero será eliminar el disco del array con la orden *mdadm --manage /dev/md126 --remove /dev/sdc3*.
Después, ejecutaremos el comando *mkfs /dev/sdc3* para simular que hemos comprado un disco nuevo.

Corremos la orden *mdadm -a /dev/md126 /dev/sdc3* para añadir el nuevo disco de igual modo que hemos hecho con el RAID 1.
Al ejecutar la orden *mdadm --detail /dev/md126* al instante vemos que el estado de la partición *sdc3* figura como *spare rebuilding*, como podemos comprobar en la siguiente captura.

![Output del comando *mdadm --detail /dev/md126* justo después de ejecutar la orden *mdadm -a /dev/md126 /dev/sdc3*](screenshots/screenshot-31-spare_rebuilding.png)

Esperamos unos minutos y volvemos a ejecutar la orden *mdadm --detail /dev/md126*, para comprobar que el estado de la partición *sdc3* pasa a figurar como *active sync*, como se observa en la siguiente imagen.

![Output del comando *mdadm --detail /dev/md126* unos minutos después de ejecutar la orden *mdadm -a /dev/md126 /dev/sdc3*](screenshots/screenshot-32-active_sync.png)


## E. Administración de discos Windows

En esta última parte, trabajaremos con nuestra máquina Windows Server 2008.

Lo primero que se nos pide es hacer una consola personalizada y guardarla como *MiConsola01.msc*.

![*MiConsola01.msc*](screenshots/screenshot-33-mysuperconsole.png)

Después, tendremos que añadir dos discos de 4GB a la máquina virtual.

Desde la consola de *Administración de equipos*, inicializamos ambos discos como discos básicos, como vemos en la imagen.

![Discos inicializados](screenshots/screenshot-34-initialized_discs.png)

En el primer disco, hacemos una única partición y la formateamos como NTFS.

![Disco 1 particionado](screenshots/screenshot-35-disk1.png)

En el segundo disco, hacemos dos particiones de igual tamaño y formateadas como FAT32.

![Disco 2 particionado](screenshots/screenshot-36-disks_2and3.png)

Convertimos los dos discos en discos dinámicos.

![Discos dinámicos](screenshots/screenshot-37-dynamic.png)

Convertimos el disco de sistema a un disco dinámico.

![Disco de sistema dinámico](screenshots/screenshot-38-disaster.png)

Eliminamos la partición del disco uno y las dos del segundo disco.

![Particiones eliminadas](screenshots/screenshot-39-emptyness.png)

Creamos un volumen simple en el disco 1 y otro en el disco 2, ambos formateados como NTFS.

![Volúmenes simples en NTFS](screenshots/screenshot-40-simple_disks.png)

Eliminamos ambos volúmenes simples y los unimos con volúmenes distribuidos. Esta nueva unidad tendrá *8GB* de capacidad.

![Volúmenes distribuidos](screenshots/screenshot-41-distributed_disks.png)

Para finalizar, eliminamos el volumen distribuido y unimos ambos discos con volúmenes distribuidos en un volumen reflejado (RAID1). Esta nueva unidad tiene *4GB* de capacidad.

![Volumen reflejado](screenshots/screenshot-42-reflected.png)



# Práctica 3

## A. Backup de un sistema en modo multiusuario mediante snapshots LVM

Lo primero que tendremos que hacer será crear una nueva máquina virtual con CentOS 7, que tendrá dos discos.
En el primero se deberá realizar una instalación mínima, dejando al segundo disco libre.

![Nueva máquina CentOs después de la instalación](screenshots/screenshot-43-after_install.png)

Instalamos el paquete *udev*.

A continuación, modificamos el archivo */etc/issue* añadiendo la frase "Copia de Seguridad practicas AS 2018".

Al salir de la sesión, vemos que el mensaje que acabamos de introducir aparece.

![Nueva máquina CentOs después de la instalación](screenshots/screenshot-44-issue.png)

Ahora, se nos pide asignar todo el espacio del segundo disco a una única partición y a crear un filesystem en ella.

Utilizaremos los siguientes comandos:

    fdisk /dev/sdb  # Creamos una nueva partición con n y escribimos en disco con w
    mkfs /dev/sdb1
    mkdir /mnt/backup
    mount /dev/sdb1 /mnt/backup    

Creamos un archivo de 1Gb en */mnt/backup* con la orden *dd if=/dev/zero of=/mnt/backup/imagen_snapshot bs=1024 count=1M*.

Añadimos la imagen que acabamos de crear al interfaz loopback con la orden *losetup -f /mnt/backup/imagen_snapshot*.

Comprobamos con *losetup -a* que el nombre del dispositivo loop creado es */dev/loop0*.

Creamos un volumen físico en */dev/loop0* con la orden *pvcreate /dev/loop0*.

Lo añadimos al grupo de volúmenes *centos* usando el comando *vgextend centos /dev/loop0*.

Creamos un snapshot de un tamaño que sea suficiente, con la orden *lvcreate -L1000M -s -n backupAS /dev/centos/root*.

Comprobamos que todo esta correcto con el comando *lvs*.

![Output del comando *lvs*](screenshots/screenshot-45-lvs.png)

Creamos el punto de montaje */mnt/snapshot* y montamos el snapshot */dev/centos/backupAS* en él con el comando *mount -o nouuid /dev/centos/backupAS /mnt/snapshot*.

Editamos de nuevo el archivo */etc/issue* y lo dejamos como estaba. Comprobamos que la versión del snapshot, que se encuentra en */mnt/snapshot/etc/issue*, no cambia, como podemos ver en la captura.

![Output del comando *cat /mnt/snapshot/etc/issue*](screenshots/screenshot-46-freeze.png)

Por último, tendremos que hacer un backup de todos los archivos del snapshot, con la orden *tar -cvpzf /mnt/backup/backup.tgz /mnt/snapshot*.

No se puede hacer un backup de los directorios */proc* y */dev* del snapshot. 
*/proc* solo existe en la memoria del sistema, es decir, no existe en disco.
*/dev* son los dispositivos de la máquina en el instante de la copia, así que no tendría sentido que se guardaran junto a los otros datos.

Sí se podría hacer un tar de los directorios */proc* y */dev* del sistema, ya que son simplemente directorios con ficheros.

Para finalizar se nos pide capturar el output de los comandos *lsblk -f* y *df -Th*.

![Output de los comandos *lsblk -f* y *df -Th*](screenshots/screenshot-47-final_output.png)



# Práctica 4

**Configuración de una intranet con un servidor Linux**

## Primera parte. Conectividad

Creamos una red anfitrión en VirtualBox y configuramos la red de la máquina Windows XP y Windows 2008 para asignarles la red que hemos creado.

Comprobamos que ambas máquinas reciben una dirección IP automáticamente.

Configuramos la máquina de CentOS utilizada en la primera práctica de tal forma que tenga dos adaptadores.
El primero tipo *NAT* y el segundo de *solo anfitrión*.

Ahora configuraremos esta máquina realizando los siguientes pasos:

- Ejecutamos la orden *uuidgen enp0s8*, que nos devuelve la string *35aa7759-d492-4bf9-9f61-9b23ad0cc62c*.
- Al introducir el comando *ip addr show* comprobaremos que tenemos dos interfaces de red, uno llamado *enp0s3* y otro *enp0s8*.
- Vamos al directorio */etc/sysconfig/network-scripts*.
- Copiamos el archivo *ifcfg-enp0s3* a *ifcfg-enp0s8*
- Editamos *ifcfg-enp0s8* para cambiar *enp0s3* por *enp0s8*.
- Cambiamos en ese archivo el parámetro *UUID* por la string anotada previamente.
- Comprobamos que tanto en *ifcfg-enp0s3* campo*ifcfg-enp0s8* el parámetro *ONBOOT* debe campo.
- Reiniciamos el servicio de red con *systemctl restart network.service*.

Hecho esto, pasamos a la máquina Windows 2008, cuya dirección *IP* es *192.168.56.102*. No tiene asociadas *DNS*, puerta de enlace ni ruta por defecto.
Tampoco podemos observar otros equipos en la red, ya que no tenemos *DNS* asignado.

La máquina Linux si tiene acceso a Internet ya que cuenta con un adaptador *NAT*.

Instalamos el paquete *bind-utils* con la orden *yum install bind-utils*, y ejecutamos el comando *nslookup horru.lsi.uniovi.es*.
Con esto comprobaremos que Linux sí puede resolver nombres, siendo el DNS *212.89.28.19*.

Ahora, deberemos añadirle un servidor secundario *156.35.14.2*, editando el archivo */etc/resolv.conf* y añadiendo la línea "nameserver 8.8.8.8".


## Segunda parte. Servidor DHCP.

Apagamos todas las máquinas virtuales y cambiamos los interfaces de red que estaban en modo *solo anfitrión* a *red interna*. Esto conlleva que el equipo anfitrión ya no forme parte de la red interna.

Arrancamos la máquina Linux. Se nos pide que el interfaz *enp0s8* tenga dirección IP estática *192.168.56.100*, con máscara *255.255.255.0*.
Para ello deberemos editar el archivo *ifcfg-enp0s8* y reiniciar la red.

A continuación instalaremos un servidor DHCP que proporcione direcciones a las dos máquinas virtuales Windows.

Para ello, lo primero será instalar el paquete *dhcp* con la orden *yum install dhcp*.
Luego, editaremos el archivo */etc/dhcp/dhcp.conf* para añadirle nuevo contenido.

Una vez editado, tendremos que arrancar el servicio *dhcpd* con la orden *systemctl start dhcpd.service*, y hacer que se arranque por defecto al iniciar el sistema con la orden *systemctl enable dhcpd.service*.

Reiniciamos las máquinas Windows y les asignamos como servidor DNS la máquina Linux.
Al hacerlo, veremos que las máquinas Windows tienen IPs dentro de la red que hemos creado.

Las máquinas Windows no tienen conectividad con el exterior, pero sí con la máquina Linux.

Las máquinas Windows no tienen conexión a Internet ya que aunque la máquina Linux ofrece el servicio de DNS, no tiene la información de los nombres de dominio.

Al ejecutar la orden *nslookup horru.lsi.uniovi.es*, podemos observar que se resuelve el nombre correctamente.

Si quisiésemos que la máquina WXP pudiera conocer que la dirección de *horru.lsi.uniovi.es* es *156.35.119.120*, tendríamos que modificar el archivo de configuración de *dhcp* del servidor Linux. 
Si tuviéramos que hacerlo sin modificar este archivo, podríamos solicitar la resolución de nombres a un servidor público.

Le indicamos al servidor DHCP que se debe encargar de proporcionar a las máquinas cliente la dirección del servidor de nombres 8.8.8.8.
Para ello haremos los siguientes pasos:

- Editamos el archivo */etc/dhcp/dhcpd.conf* y le añadimos la línea *option domain-name-servers 8.8.8.8;*,debajo de *option subnet-mask 255.255.255.0;*.
- Reiniciamos el servicio *dhcp* con la orden *systemctl restart dhcpd.service*.

Ahora, reparamos la conexión de las máquinas Windows y ejecutamos la orden *ipconfig /all*, que nos devuelve la siguiente información.

![Output del comando *ipconfig /all*](screenshots/screenshot-48-ip_config_all.png)

No se puede resolver la dirección de *www.google.es* porque la propia intranet no tiene conexión a Internet.


## Tercera parte. Uso de Linux como enrutador.

En esta última parte le vamos a dar acceso a internet a la red *192.168.56.0*. Para ello utilizaremos el enrutamiento de Linux y haremos que tenga la función de un traductor de direcciones (NAT).

Para ello, realizaremos las siguientes acciones:

- Habilitaremos el reenvío de paquetes (enrutamiento) entre interfaces en la máquina Linux. Para ver si ya está habilitado ejecutaremos la orden *systctl net.ipv4.ip_forward*. Como la salida es 0 deberemos crear el archivo */etc/sysct1.d/50-router.conf*, con la línea "net.ipv4.ip_forward=1". Una vez hecho eso, reiniciaremos el servicio de red con la orden *systemctl restart network.service*
- Habilitamos el enmascaramiento IP pasando el segundo adaptador a la zona interna del cortafuegos y activando el enmascarado en la zona pública.

Comprobamos que en las máquinas Windows podemos hacer *ping* al servidor de nombres 8.8.8.8, pero al hacerlo con *www.google.es* se nos muestra un mensaje advirtiéndonos de que no se puede encontrar el nombre *www.google.es*.



# Práctica 5

**Configuración de una intranet con servidor W2008R2**

## Primera parte. Conectividad con direcciones estáticas
 
Arrancamos las tres máquinas y comprobamos que:

- W2008 tiene acceso a Internet, ya que la orden *ping www.google.com* nos da respuesta.
- Linux no tiene una IP asignada.
- WXP tiene una IP aleatoria asignada.

Asignaremos ahora la dirección estática *192.168.56.100* al interfaz de la máquina W2008 que no está configurado como NAT. La máscara de red es *255.255.255.0*. Dejaremos vacía la dirección de la puerta de enlace.

Ahora, les asignamos la dirección IP estática *192.168.56.101* a la máquina Linux y *192.168.56.102* a la máquina WXP.

Para asignarle la dirección IP estática a Linux, tendremos que seguir los siguientes pasos:

- Orden *systemctl disable dhcpd.service* para desactivar el servicio DHCP.
- Nos movemos a la carpeta */etc/sysconfig/network-scripts/*.
- Orden *rm ifcfg-enp0s8*
- Lo editamos y modificamos el parámetro *BOOTPROTO* a "none", y añadimos las líneas "IPADDR=192.168.56.101" y "NETMASK=255.255.255.0".
- Orden *systemctl restart network.service*.

Hacemos ping entre las tres máquinas, y observamos que recibimos respuesta al hacer ping entre W2008 y WXP y viceversa, entre W2008 y Linux y viceversa, y entre las máquinas WXP y Linux.

Anotamos ahora las rutas de las tres máquinas, y las conexiones activas de cada una.

![Rutas de Linux](screenshots/screenshot-49-route_linux.png)

![Rutas de W2008](screenshots/screenshot-50-route_w2008.png)

![Rutas de WXP](screenshots/screenshot-51-route_wxp.png)

Al hacer *ping* desde las tres máquinas al exterior, comprobamos que solo W2008 tiene conexión a Internet.

Ejecutamos la orden *ipconfig /all* y determinamos que la dirección del servidor DHCP es *10.0.2.2*.


## Segunda parte. Instalación del rol DHCP en el servidor Windows

En esta segunda parte configuramos W2008 para que tenga el rol de *Servidor DHCP*.

Configuramos ahora Linux para que reciba una dirección de un servidor DHCP. 

Ejecutaremos la orden *ip route list* que nos devuelve la siguiente información.

![Rutas de Linux después de que reciba una dirección de un servidor DHCP](screenshots/screenshot-52-route_linux_after_dhcp.png)

No tenemos salida al exterior desde Linux pues el servidor W2008 aún no está funcionando como un router.

Podemos sin embargo conectarnos a la dirección IP *192.168.56.100* desde Linux ya que identifica a la máquina W2008 que le proporciona a Linux servicio DHCP.

Entramos en el servidor DHCP (W2008), y comprobamos que efectivamente está Linux en la lista de concesiones como se observa en la imagen.

![Linux en la lista de concesiones](screenshots/screenshot-53-linux_from_w2008.png)

Arrancamos WXP e indicamos en las propiedades de su interfaz de red que reciba una dirección IP y un DNS automáticamente.

Ejecutamos la orden *route print* que nos devuelve la siguiente información.

![Rutas de Windows después de que reciba una dirección de un servidor DHCP](screenshots/screenshot-54-route_wxp_after_dhcp.png)

No tenemos salida al exterior desde WXP ya que el servidor W2008 no proporciona servicios de enrutamiento.

Podemos a pesar de ello conectarnos a la dirección IP *192.168.56.100* desde WXP ya que es la dirección de la máquina W2008 que le proporciona a WXP servicio DHCP.

Entramos en el servidor DHCP (W2008), y comprobamos que ahora la máquina WXP aparece junto a la máquina Linux en la lista de concesiones, como se puede ver en la captura.

![WXP y Linux en la lista de concesiones](screenshots/screenshot-55-wxp_from_w2008.png)


## Tercera parte. Uso de W2008 como enrutador.

En esta parte vamos a dar acceso a Internet a la red *192.168.56.0*. Para ello utilizaremos el servicio "Enrutamiento y Acceso Remoto" de Windows 2008 y haremos como traductor de direcciones (NAT).

Agregamos en W2008 el rol *Servicios de acceso y directivas de redes*, y lo configuramos para que la dirección pública para conectarse a Internet sea *10.0.2.15*.

Rebotamos las máquinas WXP y Linux y anotamos sus tablas de rutas.

![Rutas de WXP](screenshots/screenshot-56-route_wxp_after_routing.png)

![Rutas de Linux](screenshots/screenshot-57-route_linux_after_routing.png)

Ninguna de las dos máquinas tiene salida al exterior ya que no hemos configurado correctamente la ruta por defecto.

La ruta por defecto debería ser la del servidor de enrutamiento, que en nuestro caso es la máquina W2008.

Establecemos la ruta por defecto en Linux con la orden *ip route add default via 192.168.56.100*.

Establecemos la ruta por defecto en Windows con la orden *route add 0.0.0.0 mask 0.0.0.0 192.168.56.100 metric 25*.

Comprobamos con la orden *ping www.lukesmith.xyz* que tenemos conexión a Internet desde las tres máquinas.

![Orden *ping www.lukesmith.xyz* en Linux](screenshots/screenshot-58-linux_internet_access.png)


## Cuarta parte. Opciones en el servidor de configuración DHCP.

Apagamos las máquinas clientes y las volvemos a arrancar. Observaremos que las rutas por defecto vuelven a ser incorrectamente *192.168.56.1*.

Para arreglar el problema, entraremos en la administración del servidor DHCP e indicaremos en la opción "Enrutador" que la puerta de enlace es *192.168.56.100* en vez de la indicada anteriormente, que era *192.168.56.1*.

![Nueva puerta de enlace en el servidor DHCP](screenshots/screenshot-59-routing_new_ip.png)

Reiniciamos los clientes para que reciban por DHCP la dirección IP junto con la dirección correcta de la puerta de enlace de la ruta por defecto.

Observamos que la tabla de rutas es correcta y que de nuevo tenemos acceso al exterior, como vemos en la siguiente captura de la máquina Linux donde se ejecutó la orden *ping www.crunchyroll.com*.

![Orden *ping www.crunchyroll.com* en Linux](screenshots/screenshot-60-linux_crunchyroll.png)



# Práctica 6

**DNS y Samba**

Lo primero que se nos solicita es el apuntar las direcciones MAC de la máquina WXP y Linux.

La dirección MAC de Linux es *080027C64FC6*.

La dirección MAC de WXP es *080027AD11A5*.

Entraremos en el servidor DHCP y agregamos una reserva para Linux y WXP en las direcciones *192.168.56.110* y *192.168.56.111*.


## Primera parte. DNS.

En esta primera parte deberemos crear un servidor DNS en la máquina W2008.

Creamos una zona de búsqueda directa principal *as.local* e inversa *192.168.56*.

Damos de alta a las tres máquinas con nombres *w2008r2.as.local*, *wxp.as.local* y *linux.as.local*.

Añadimos por último un reenviador no condicionado, en nuestro caso el *8.8.8.8*, que se encuentra en las propiedades del DNS *w2008r2*, como se observa en la captura.

![Reenviador no condicionado](screenshots/screenshot-61-resender.png)

Observamos que las máquinas cliente tienen acceso al exterior mediante la orden *ping www.lukesmith.xyz*.

![Orden *ping www.lukesmith.xyz* desde WXP](screenshots/screenshot-62-luke_wxp.png)

![Orden *ping www.lukesmith.xyz* desde Linux](screenshots/screenshot-63-luke_linux.png)


## Segunda parte. Compartición de archivos y Samba.

Creamos dos usuarios *asuser*, uno en W2008 desde el panel de control con contraseña *sakura98Cardcaptor$*, y otro en Linux con la orden *adduser asuser* y con contraseña *tsundere*, utilizando el comando *passwd asuser* e insertando la nueva contraseña.

Ahora, deberemos compartir la carpeta desde Linux y desde W2008. 

En Windows, una vez iniciada sesión con el nuevo usuario, entramos en el menú contextual sobre su carpeta y le damos a *Compartir con... -> Todos*.

En Linux, debemos instalar los paquetes *samba* y *samba-client* y configurar una serie de opciones, como vemos en la captura.

![Configurando Samba](screenshots/screenshot-64-samba.png)

Ahora, arrancamos la máquina WXP para conectarnos a ambos recursos compartidos desde *Mis sitios de Red*.

Primero nos conectamos a Linux, con la dirección *\\192.168.56.110\asuser*, y creamos un archivo *Neon Genesis Evangelion.txt*.

![Archivo *Neon Genesis Evangelion.txt* desde WXP](screenshots/screenshot-65-evangelion_from_wxp.png)

Vemos que desde Linux podemos comprobar que el archivo existe, mediante la orden *cat* al archivo, como se observa en la captura.

![Archivo *Neon Genesis Evangelion.txt* desde Linux](screenshots/screenshot-66-evangelion_from_linux.png)

Luego nos conectamos a W2008, con la dirección *\\192.168.56.100\Users\asuser*.

![Carpeta compartida del usuario de W2008 desde WXP](screenshots/screenshot-67-w2008_asuser_from_wxp.png)

Podemos ahora observar que se nos muestran ambas carpetas compartidas desde WXP para uso futuro.

![Ambas carpetas compartidas desde WXP](screenshots/screenshot-68-both_net_sites.png)



# Práctica 7

**Servidores Web en Linux: Apache**

## 1. Instalación

Configuramos la máquina Linux para que tenga acceso a Internet a través del servidor W2008, como en la práctica anterior.

Observamos que Linux tiene acceso a la red, y ejecutamos la orden *hostnamectl set-hostname linux.as.local*, que comprobamos con el comando *uname -a*.

También comprobamos que se resuelve la dirección linux.as.local desde la máquina Linux y WXP.

En la zona del servidor DNS añadimos *www.midominio.local* con la misma dirección IP que la máquina Linux.

Comprobamos que tanto la máquina Linux como WXP resuelven correctamente la dirección asignada a *www.midominio.local*, como se observa en la siguiente captura de Linux.

![Orden *ping www.midominio.local* desde Linux](screenshots/screenshot-69-midominio_local.png)

Comprobamos que el Apache está instalado en la máquina Linux. No lo está, así que lo instalamos con la orden *yum install httpd*.

Arrancamos el servicio *httpd* con la orden *systemctl start httpd.service* y lo hacemos que el servicio empiece al botar con la orden *systemctl enable httpd.service*.

Añadimos una nueva regla al firewall para permitir las conexiones *http*, con las órdenes *firewall-cmd --permanent --add-service=http* y *firewall-cmd --reload*.

Lanzamos un navegador en el WXP y accede a *http://www.midominio.local*, como observamos en la siguiente imagen.

![URL *http://www.midominio.local* desde el navegador de WXP](screenshots/screenshot-70-wxp_browser.png)

Ahora, desde Linux, creamos dentro del directorio */var/www/html* un archivo *index.html* y comprobamos que lo podemos visualizar desde *http://www.midominio.local* en el navegador de WXP.

![URL *http://www.midominio.local* desde el navegador de WXP una vez creado el archivo *index.html*](screenshots/screenshot-71-index_html.png)


## 2. Configuración de las páginas web de los usuarios

Editamos el fichero */etc/httpd/conf.d/userdir.conf* para que cada usuario pueda tener su propia página web.

Aplicamos los permisos al directorio del usuario asuser con la orden *chmod 711 /home/asuser*.

Ejecutamos la orden *setsebool -P httpd_read_user_content on* para permitir que Apache pueda leer contenidos localizados en los directorios de inicio de los usuarios locales.

A continuación corremos la orden *setsebool -P httpd_enable_homedirs on* para habilitar el uso de los directorios *~/public_html* de los usuarios.

Entramos en una terminal como el usuario *asuser* y creamos en nuestro directorio la carpeta */public_html*, y dentro de ella un fichero *index.html*. Aplicamos los permisos de acceso adecuados con la orden *chmod 755 -R public_html*.

Reiniciamos el servicio *httpd* con la orden *systemctl restart httpd.service*.

Por último, arrancamos la máquina WXP y entramos en la URL *http://www.midominio.local/~asuser*.

![URL *http://www.midominio.local/~asuser* desde el navegador de WXP](screenshots/screenshot-72-asuser_mainpage.png)


## 3. Configuración del servidor Apache

### A. Ubicación

Crearemos una nueva ubicación para la página web. Para ello crearemos el directorio */as/web* y copiaremos en ella el fichero *index.html* con la orden *cat /var/www/html/index.html >> index.html* (También se podría haber utilizado el comando *cp*).

Editaremos el archivo de configuración presente en */etc/httpd/conf/httpd.conf* para que la directiva *DocumentRoot* busque los documentos en el nuevo directorio */as/web*.

Sustituimos además la sección *<Directory "/var/www"> por la sección *<Directory "/as/web">*, modificando también sus parámetros.

Restauramos ahora el servicio *httpd*, asignamos el contexto *httpd_sys_content_t* a través de *chcon* con la orden *chcon -R -h -t httpd_sys_content_t /as/web* y comprobamos que la página *www.midominio.local* ha cambiado.

![URL *http://www.midominio.local* desde el navegador de WXP, ahora leída desde */as/web*](screenshots/screenshot-73-as_web.png)


## B. ServerName

Modificamos las directivas *ServerAdmin* y *ServerName* del fichero */etc/httpd/conf/httpd.conf* con nuestro email y con el nombre *www.midominio.local*.

También deberemos hacer que el servidor escuche en el puerto 9999. Para ello, cambiamos el puerto 80 a 9999 en la directiva *Listen*, y cambiamos el nombre del servidor a *www.midominio.local:9999* en la directiva *ServerName*.

Necesitamos añadirle una nueva regla al firewall de Linux, para ello, ejecutaremos la orden *firewall-cmd --zone=public --add-port=9999 /tcp*.

Comprobamos que ahora desde WXP con la URL *http://www.midominio.local:9999* podemos visualizar la página.

![URL *http://www.midominio.local:9999* desde el navegador de WXP](screenshots/screenshot-74-port_9999.png)

Volvemos a dejar al servidor escuchando en el puerto 80.


## C. Repositorios

Renombramos el archivo *index.html* a *índice.html*. Recargamos la página para que se borre la cache y al consultar de nuevo *www.midominio.local* vemos que se nos muestra la página de *Testing 123...* ya que no se está buscando una archivo *index.html* que no existe.

![URL *http://www.midominio.local* desde el navegador de WXP: *Testing 123...*](screenshots/screenshot-75-indice_html.png)

Editamos el fichero */etc/httpd/conf.d/welcome.conf* y comentamos todas las líneas. Con ello desactivamos la presentación de la página de *Testing 123...* para el caso de que no se encuentre el fichero *index.html*.

Restauramos de nuevo el servicio *httpd* y vemos que se nos muestra un error advirtiéndonos de que el acceso está restringido.

![URL *http://www.midominio.local* desde el navegador de WXP: *Forbidden*](screenshots/screenshot-76-forbidden.png)

Modificamos la sección que creamos anteriormente para */as/web*, cambiando la primera línea por *Options Indexes FollowSymLinks*.

Volvemos a restaurar el servicio, recargamos la página y comprobamos que ahora podemos visualizar el contenido de los directorios.

![URL *http://www.midominio.local* desde el navegador de WXP: *Contenido de los directorios*](screenshots/screenshot-77-index_of.png)

Hacemos desde el navegador de WXP un acceso a una página no existente dentro de nuestro dominio, y en Linux al acceder al fichero de log en */var/log/httpd/access_log* observaremos el intento de acceso (Petición GET) a la página no existente */evangelion*, como se ve en la captura.

![Contenido de */var/log/httpd/access_log*](screenshots/screenshot-78-access_log.png)



# Práctica 8

**Servidor de bases de datos (MySQL/MariaDB) y Content Management System (WordPress, Joomla) sobre XAMPP**

## Parte 1. Obligatoria.

Queremos montar un CMS ligero (WordPress) en el servidor Windows y uno mediano (Joomla) en el servidor Linux.

Empezamos con el servidor W2008, realizando los siguientes pasos.


### Guía de instalación de Wordpress en W2008

- Descargamos XAMPP *7.3.6* desde *https://www.apachefriends.org/* y lo instalamos en nuestra máquina.
- Instalamos desde el *Panel de Control* de XAMPP los módulos de *Apache*, *MySQL* and *FileZilla*.
- Descargamos Wordpress *5.2.2* desde *https://es.wordpress.org/download/*.
- Creamos una base de datos vacía en MySQL llamada *wordpresssb* desde XAMPP.
- Descomprimimos el *zip* con Wordpress en la carpeta *\xampp\htdocs\wordpress*.
- Vamos a la dirección *localhost/wordpress/* en nuestro navegador y comenzamos la instalación. Tendremos que especificar que la base de datos es la creada en XAMPP previamente.
- Una vez terminada la instalación, accedemos con el usuario y contraseña de admin que hemos creado durante la fase de instalación.
- Vamos al apartado *Apariencia* e instalamos el tema *Mesmerice* desde el *MarketPlace*. Una vez instalado, lo activamos.

Se puede observar en la siguiente captura que nuestro sitio web ya tiene la apariencia del nuevo tema *Mesmerice*.

![Wordpress con el tema *Mesmerice*](screenshots/screenshot-79-wordpress_mesmerice.png)


### Guía de mantenimiento de Wordpress en W2008

- Si queremos añadir una nueva entrada en el blog, tendremos que ir al apartado *Entradas*. En este apartado podremos crear, eliminar y editar entradas de nuestro sitio web.
- Si queremos cambiar el título de
 la página, al visitar el sitio observaremos que arriba tendremos una opción *Personalizar*, con la que podremos personalizar los títulos y subtítulos de la página.
- También podremos cambiar la estructura y bloques de la página desde la opción *Personalizar* mencionada en el párrafo anterior.
- Para añadir una nueva página tendremos que ir al apartado *Páginas*, que permite crear, eliminar y modificar páginas.

A continuación se muestran capturas de la página principal del sitio web, la entrada *Mil razones por las que deberías usar software libre* y la página *Acerca de...*.

![Página principal](screenshots/screenshot-80-main_page.png)

![Página *Acerca de...*](screenshots/screenshot-81-about.png)

![Entrada *Mil razones por las que deberías usar software libre*](screenshots/screenshot-82-software_libre.png)


## Guía de instalación de Joomla en Linux

- Desde la máquina Linux, orden *yum install wget*.
- Descargamos *XAMPP 7.3.6* con la orden *wget https://www.apachefriends.org/xampp-files/7.3.6/xampp-linux-x64-7.3.6-2-installer.run*.
- Hacemos el archivo ejecutable con la orden *chmod +x xampp-linux-x64-7.3.6-2-installer.run*.
- Corremos el archivo con la orden *./xampp-linux-x64-7.3.6-2-installer.run*.
- Nos movemos al directorio */opt/lampp/htdocs/*.
- Creamos un directorio */htdocs/joomla*.
- Descargamos *Joomla 3.9.8* con la orden *wget https://downloads.joomla.org/es/cms/joomla3/3-9-8/Joomla_3-9-9-Stable-Full_Package.zip*.
- Instalamos los paquetes *zip y unzip*.
- Descomprimimos el paquete de *Joomla 3.9.8* en el directorio */htdocs/joomla*.
- Instalamos el paquete *net-tools*.
- Cambiamos el puerto de escucha del servicio *httpd* en */etc/httpd/conf/httpd.conf* para que no sea el puerto 80.
- En la carpeta */opt/lampp* ejecutamos la orden *./lampp restart*, y nos debería mostrar *ok* en *Apache*, *MySQL* y *ProFTPD*.
- Modificamos el archivo */opt/lampp/etc/extra/httpd-xampp.conf* y en la entrada *Directory "/opt/lampp/phpmyadmin"* cambiamos el parámetro *Require local* por *Require all granted*. Ésto permite que nos podamos conectar a *phpmyadmin* desde el exterior.
- Volvemos a correr la orden *./lampp restart* desde el directorio */opt/lampp*.
- Corremos la orden *chmod -R 777 joomla/* desde el directorio */opt/lampp/htdocs*.
- Desde el navegador del equipo W2008 nos conectamos a la dirección *httpd://192.168.56.110/phpmyadmin* y creamos una nueva base de datos *joomladb* (Se puede escoger cualquier nombre para la base de datos).
- Desde el mismo navegador entramos en *httpd://192.168.56.110/joomla* y comenzamos la instalación de Joomla.


## Guía de mantenimiento de Joomla en Linux


